{"ast":null,"code":"import React,{useState,useEffect}from'react';import QuestionDisplay from'./QuestionDisplay';import'../styles/QuizContainer.css';import{jsxs as _jsxs,jsx as _jsx}from\"react/jsx-runtime\";const QuizContainer=_ref=>{let{questions,filteredQuestions,correctAnswers,bookmarkedQuestions,updateStats,toggleBookmark,searchQuestions}=_ref;const[currentQuestion,setCurrentQuestion]=useState(null);const[selectedAnswers,setSelectedAnswers]=useState([]);const[feedback,setFeedback]=useState({visible:false,isCorrect:false,message:''});const[currentMode,setCurrentMode]=useState('random');const[currentIndex,setCurrentIndex]=useState(0);const[searchQuery,setSearchQuery]=useState('');// Încărcăm întrebarea curentă când se modifică questions sau currentMode\nuseEffect(()=>{if(questions.length>0){loadQuestion();}},[questions,currentMode,filteredQuestions]);const loadQuestion=()=>{// Resetăm starea\nsetFeedback({visible:false,isCorrect:false,message:''});setSelectedAnswers([]);// Utilizăm întrebările filtrate sau toate întrebările\nconst questionPool=currentMode===\"search\"?filteredQuestions:questions;if(questionPool.length===0){setCurrentQuestion(null);return;}// Determinăm ce întrebare să încărcăm în funcție de mod\nlet newIndex=currentIndex;if(currentMode===\"random\"){newIndex=Math.floor(Math.random()*questionPool.length);}else if(currentMode===\"bookmarked\"){// Găsim toate întrebările salvate\nconst bookmarked=questionPool.filter(q=>bookmarkedQuestions.has(q.numar));if(bookmarked.length===0){setCurrentQuestion(null);return;}// Alegem o întrebare aleatorie dintre cele salvate\nconst randomBookmarked=Math.floor(Math.random()*bookmarked.length);const bookmarkedQuestion=bookmarked[randomBookmarked];newIndex=questionPool.findIndex(q=>q.numar===bookmarkedQuestion.numar);}else if(currentMode===\"search\"){// Pentru modul de căutare, folosim prima întrebare găsită\nnewIndex=0;}// Pentru sequential, folosim currentIndex așa cum este\n// Ne asigurăm că newIndex este în limite\nif(newIndex>=questionPool.length){newIndex=0;}setCurrentIndex(newIndex);setCurrentQuestion(questionPool[newIndex]);};const nextQuestion=()=>{if(currentMode===\"sequential\"){setCurrentIndex(prevIndex=>{const nextIndex=prevIndex+1;return nextIndex>=questions.length?0:nextIndex;});}else if(currentMode===\"search\"){setCurrentIndex(prevIndex=>{const nextIndex=prevIndex+1;return nextIndex>=filteredQuestions.length?0:nextIndex;});}loadQuestion();};const handleAnswerSelection=letter=>{setSelectedAnswers(prev=>{const index=prev.indexOf(letter);if(index===-1){// Adăugăm selecția\nconst newSelected=[...prev,letter];newSelected.sort();return newSelected;}else{// Eliminăm selecția\nreturn prev.filter(l=>l!==letter);}});};const checkAnswer=()=>{if(!currentQuestion)return;const questionNumber=currentQuestion.numar;const correct=correctAnswers[questionNumber]||\"\";// Convertim selecțiile în string pentru comparație\nconst userAnswer=selectedAnswers.join('');// Determinăm dacă răspunsul este corect\nconst isCorrect=userAnswer===correct;// Actualizăm statisticile\nupdateStats(isCorrect);// Afișăm rezultatul\nsetFeedback({visible:true,isCorrect,message:isCorrect?`Corect! Ai selectat răspunsul corect.`:`Incorect! Răspunsul corect este ${correct}.`});};const handleModeChange=e=>{const newMode=e.target.value;setCurrentMode(newMode);if(newMode===\"search\"){// Nu încărcăm întrebarea aici pentru modul search, doar când se face căutarea\n}else{// Resetăm indexul pentru celelalte moduri și încărcăm o nouă întrebare\nsetCurrentIndex(0);}};const handleSearch=()=>{if(searchQuestions(searchQuery)){// Dacă s-au găsit rezultate, încărcăm prima întrebare\nsetCurrentIndex(0);}};const handleBookmarkToggle=()=>{if(currentQuestion){toggleBookmark(currentQuestion.numar);}};return/*#__PURE__*/_jsxs(\"div\",{className:\"quiz-container\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"question-counter\",children:currentQuestion&&/*#__PURE__*/_jsxs(\"span\",{children:[\"\\xCEntrebarea \",currentQuestion.numar,\" din \",questions.length]})}),/*#__PURE__*/_jsxs(\"div\",{className:\"controls\",children:[/*#__PURE__*/_jsxs(\"select\",{value:currentMode,onChange:handleModeChange,className:\"question-selector\",children:[/*#__PURE__*/_jsx(\"option\",{value:\"random\",children:\"\\xCEntrebare aleatorie\"}),/*#__PURE__*/_jsx(\"option\",{value:\"sequential\",children:\"\\xCEntreb\\u0103ri \\xEEn ordine\"}),/*#__PURE__*/_jsx(\"option\",{value:\"bookmarked\",children:\"\\xCEntreb\\u0103ri salvate\"}),/*#__PURE__*/_jsx(\"option\",{value:\"search\",children:\"C\\u0103utare \\xEEntreb\\u0103ri\"})]}),/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(\"span\",{className:`bookmark-icon ${bookmarkedQuestions.has(currentQuestion===null||currentQuestion===void 0?void 0:currentQuestion.numar)?'bookmark-active':'bookmark-inactive'}`,onClick:handleBookmarkToggle,children:\"\\u2605\"})})]}),currentMode===\"search\"&&/*#__PURE__*/_jsxs(\"div\",{className:\"search-container\",children:[/*#__PURE__*/_jsx(\"input\",{type:\"text\",value:searchQuery,onChange:e=>setSearchQuery(e.target.value),placeholder:\"Caut\\u0103 dup\\u0103 num\\u0103r sau text...\",className:\"search-input\",onKeyPress:e=>e.key==='Enter'&&handleSearch()}),/*#__PURE__*/_jsx(\"button\",{onClick:handleSearch,className:\"btn\",children:\"Caut\\u0103\"}),/*#__PURE__*/_jsx(\"div\",{className:\"search-hint\",children:\"Po\\u021Bi c\\u0103uta dup\\u0103 num\\u0103rul exact al \\xEEntreb\\u0103rii (ex: 25) sau dup\\u0103 text.\"})]}),currentQuestion?/*#__PURE__*/_jsx(QuestionDisplay,{question:currentQuestion,selectedAnswers:selectedAnswers,onAnswerSelect:handleAnswerSelection,feedback:feedback,correctAnswer:correctAnswers[currentQuestion.numar]||\"\"}):/*#__PURE__*/_jsx(\"div\",{className:\"question-placeholder\",children:currentMode===\"bookmarked\"?\"Nu ai întrebări salvate. Salvează întrebări folosind steluța.\":currentMode===\"search\"?\"Nicio întrebare nu conține termenul căutat. Încearcă o altă căutare.\":\"Nicio întrebare disponibilă.\"}),/*#__PURE__*/_jsx(\"div\",{className:\"multiple-choice-hint\",children:\"Selecteaz\\u0103 toate r\\u0103spunsurile corecte (pot fi una sau mai multe variante).\"}),/*#__PURE__*/_jsxs(\"div\",{className:\"button-container\",children:[/*#__PURE__*/_jsx(\"button\",{className:\"btn btn-check\",onClick:checkAnswer,disabled:!currentQuestion||selectedAnswers.length===0,children:\"Verific\\u0103 r\\u0103spunsul\"}),/*#__PURE__*/_jsx(\"button\",{className:\"btn\",onClick:nextQuestion,children:\"Urm\\u0103toarea \\xEEntrebare\"})]})]});};export default QuizContainer;","map":{"version":3,"names":["React","useState","useEffect","QuestionDisplay","jsxs","_jsxs","jsx","_jsx","QuizContainer","_ref","questions","filteredQuestions","correctAnswers","bookmarkedQuestions","updateStats","toggleBookmark","searchQuestions","currentQuestion","setCurrentQuestion","selectedAnswers","setSelectedAnswers","feedback","setFeedback","visible","isCorrect","message","currentMode","setCurrentMode","currentIndex","setCurrentIndex","searchQuery","setSearchQuery","length","loadQuestion","questionPool","newIndex","Math","floor","random","bookmarked","filter","q","has","numar","randomBookmarked","bookmarkedQuestion","findIndex","nextQuestion","prevIndex","nextIndex","handleAnswerSelection","letter","prev","index","indexOf","newSelected","sort","l","checkAnswer","questionNumber","correct","userAnswer","join","handleModeChange","e","newMode","target","value","handleSearch","handleBookmarkToggle","className","children","onChange","onClick","type","placeholder","onKeyPress","key","question","onAnswerSelect","correctAnswer","disabled"],"sources":["/Users/dragosudrea/repos/quiz-react-app/src/components/QuizContainer.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport QuestionDisplay from './QuestionDisplay';\r\nimport '../styles/QuizContainer.css';\r\n\r\nconst QuizContainer = ({\r\n  questions,\r\n  filteredQuestions,\r\n  correctAnswers,\r\n  bookmarkedQuestions,\r\n  updateStats,\r\n  toggleBookmark,\r\n  searchQuestions\r\n}) => {\r\n  const [currentQuestion, setCurrentQuestion] = useState(null);\r\n  const [selectedAnswers, setSelectedAnswers] = useState([]);\r\n  const [feedback, setFeedback] = useState({ visible: false, isCorrect: false, message: '' });\r\n  const [currentMode, setCurrentMode] = useState('random');\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const [searchQuery, setSearchQuery] = useState('');\r\n\r\n  // Încărcăm întrebarea curentă când se modifică questions sau currentMode\r\n  useEffect(() => {\r\n    if (questions.length > 0) {\r\n      loadQuestion();\r\n    }\r\n  }, [questions, currentMode, filteredQuestions]);\r\n\r\n  const loadQuestion = () => {\r\n    // Resetăm starea\r\n    setFeedback({ visible: false, isCorrect: false, message: '' });\r\n    setSelectedAnswers([]);\r\n    \r\n    // Utilizăm întrebările filtrate sau toate întrebările\r\n    const questionPool = (currentMode === \"search\") ? filteredQuestions : questions;\r\n    \r\n    if (questionPool.length === 0) {\r\n      setCurrentQuestion(null);\r\n      return;\r\n    }\r\n    \r\n    // Determinăm ce întrebare să încărcăm în funcție de mod\r\n    let newIndex = currentIndex;\r\n    \r\n    if (currentMode === \"random\") {\r\n      newIndex = Math.floor(Math.random() * questionPool.length);\r\n    } else if (currentMode === \"bookmarked\") {\r\n      // Găsim toate întrebările salvate\r\n      const bookmarked = questionPool.filter(q => bookmarkedQuestions.has(q.numar));\r\n      if (bookmarked.length === 0) {\r\n        setCurrentQuestion(null);\r\n        return;\r\n      }\r\n      // Alegem o întrebare aleatorie dintre cele salvate\r\n      const randomBookmarked = Math.floor(Math.random() * bookmarked.length);\r\n      const bookmarkedQuestion = bookmarked[randomBookmarked];\r\n      newIndex = questionPool.findIndex(q => q.numar === bookmarkedQuestion.numar);\r\n    } else if (currentMode === \"search\") {\r\n      // Pentru modul de căutare, folosim prima întrebare găsită\r\n      newIndex = 0;\r\n    }\r\n    // Pentru sequential, folosim currentIndex așa cum este\r\n    \r\n    // Ne asigurăm că newIndex este în limite\r\n    if (newIndex >= questionPool.length) {\r\n      newIndex = 0;\r\n    }\r\n    \r\n    setCurrentIndex(newIndex);\r\n    setCurrentQuestion(questionPool[newIndex]);\r\n  };\r\n\r\n  const nextQuestion = () => {\r\n    if (currentMode === \"sequential\") {\r\n      setCurrentIndex(prevIndex => {\r\n        const nextIndex = prevIndex + 1;\r\n        return nextIndex >= questions.length ? 0 : nextIndex;\r\n      });\r\n    } else if (currentMode === \"search\") {\r\n      setCurrentIndex(prevIndex => {\r\n        const nextIndex = prevIndex + 1;\r\n        return nextIndex >= filteredQuestions.length ? 0 : nextIndex;\r\n      });\r\n    }\r\n    \r\n    loadQuestion();\r\n  };\r\n\r\n  const handleAnswerSelection = (letter) => {\r\n    setSelectedAnswers(prev => {\r\n      const index = prev.indexOf(letter);\r\n      \r\n      if (index === -1) {\r\n        // Adăugăm selecția\r\n        const newSelected = [...prev, letter];\r\n        newSelected.sort();\r\n        return newSelected;\r\n      } else {\r\n        // Eliminăm selecția\r\n        return prev.filter(l => l !== letter);\r\n      }\r\n    });\r\n  };\r\n\r\n  const checkAnswer = () => {\r\n    if (!currentQuestion) return;\r\n    \r\n    const questionNumber = currentQuestion.numar;\r\n    const correct = correctAnswers[questionNumber] || \"\";\r\n    \r\n    // Convertim selecțiile în string pentru comparație\r\n    const userAnswer = selectedAnswers.join('');\r\n    \r\n    // Determinăm dacă răspunsul este corect\r\n    const isCorrect = userAnswer === correct;\r\n    \r\n    // Actualizăm statisticile\r\n    updateStats(isCorrect);\r\n    \r\n    // Afișăm rezultatul\r\n    setFeedback({\r\n      visible: true,\r\n      isCorrect,\r\n      message: isCorrect \r\n        ? `Corect! Ai selectat răspunsul corect.` \r\n        : `Incorect! Răspunsul corect este ${correct}.`\r\n    });\r\n  };\r\n\r\n  const handleModeChange = (e) => {\r\n    const newMode = e.target.value;\r\n    setCurrentMode(newMode);\r\n    \r\n    if (newMode === \"search\") {\r\n      // Nu încărcăm întrebarea aici pentru modul search, doar când se face căutarea\r\n    } else {\r\n      // Resetăm indexul pentru celelalte moduri și încărcăm o nouă întrebare\r\n      setCurrentIndex(0);\r\n    }\r\n  };\r\n\r\n  const handleSearch = () => {\r\n    if (searchQuestions(searchQuery)) {\r\n      // Dacă s-au găsit rezultate, încărcăm prima întrebare\r\n      setCurrentIndex(0);\r\n    }\r\n  };\r\n\r\n  const handleBookmarkToggle = () => {\r\n    if (currentQuestion) {\r\n      toggleBookmark(currentQuestion.numar);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"quiz-container\">\r\n      <div className=\"question-counter\">\r\n        {currentQuestion && (\r\n          <span>Întrebarea {currentQuestion.numar} din {questions.length}</span>\r\n        )}\r\n      </div>\r\n      \r\n      <div className=\"controls\">\r\n        <select \r\n          value={currentMode}\r\n          onChange={handleModeChange}\r\n          className=\"question-selector\"\r\n        >\r\n          <option value=\"random\">Întrebare aleatorie</option>\r\n          <option value=\"sequential\">Întrebări în ordine</option>\r\n          <option value=\"bookmarked\">Întrebări salvate</option>\r\n          <option value=\"search\">Căutare întrebări</option>\r\n        </select>\r\n        \r\n        <div>\r\n          <span \r\n            className={`bookmark-icon ${bookmarkedQuestions.has(currentQuestion?.numar) ? 'bookmark-active' : 'bookmark-inactive'}`}\r\n            onClick={handleBookmarkToggle}\r\n          >\r\n            ★\r\n          </span>\r\n        </div>\r\n      </div>\r\n      \r\n      {currentMode === \"search\" && (\r\n        <div className=\"search-container\">\r\n          <input\r\n            type=\"text\"\r\n            value={searchQuery}\r\n            onChange={(e) => setSearchQuery(e.target.value)}\r\n            placeholder=\"Caută după număr sau text...\"\r\n            className=\"search-input\"\r\n            onKeyPress={(e) => e.key === 'Enter' && handleSearch()}\r\n          />\r\n          <button onClick={handleSearch} className=\"btn\">Caută</button>\r\n          <div className=\"search-hint\">\r\n            Poți căuta după numărul exact al întrebării (ex: 25) sau după text.\r\n          </div>\r\n        </div>\r\n      )}\r\n      \r\n      {currentQuestion ? (\r\n        <QuestionDisplay\r\n          question={currentQuestion}\r\n          selectedAnswers={selectedAnswers}\r\n          onAnswerSelect={handleAnswerSelection}\r\n          feedback={feedback}\r\n          correctAnswer={correctAnswers[currentQuestion.numar] || \"\"}\r\n        />\r\n      ) : (\r\n        <div className=\"question-placeholder\">\r\n          {currentMode === \"bookmarked\" \r\n            ? \"Nu ai întrebări salvate. Salvează întrebări folosind steluța.\" \r\n            : currentMode === \"search\"\r\n            ? \"Nicio întrebare nu conține termenul căutat. Încearcă o altă căutare.\"\r\n            : \"Nicio întrebare disponibilă.\"}\r\n        </div>\r\n      )}\r\n      \r\n      <div className=\"multiple-choice-hint\">\r\n        Selectează toate răspunsurile corecte (pot fi una sau mai multe variante).\r\n      </div>\r\n      \r\n      <div className=\"button-container\">\r\n        <button \r\n          className=\"btn btn-check\" \r\n          onClick={checkAnswer}\r\n          disabled={!currentQuestion || selectedAnswers.length === 0}\r\n        >\r\n          Verifică răspunsul\r\n        </button>\r\n        <button className=\"btn\" onClick={nextQuestion}>\r\n          Următoarea întrebare\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default QuizContainer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}